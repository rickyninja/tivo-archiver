#!/usr/bin/perl

use strict;
use warnings;
use lib "$ENV{HOME}/lib";
use Carp;
use Tivo::Util;
use Tivo::Client;
use Data::Dumper;
use Fcntl qw(:flock);
use Sys::Syslog;
use YAML qw(LoadFile DumpFile);
use File::Copy qw(move);
use File::Path qw(make_path);
use Time::Local;

my $debug = $ENV{DEBUG};
my $use_cache = $ENV{USECACHE};
my $script_name = (split m{/}, $0)[-1];
openlog($script_name, "ndelay,pid", "local0");


my $lockfile = "/var/run/$script_name.pid";
my $lock;
unless (open $lock, '>', $lockfile) {
    log_error("Failed to open $lockfile: $!");
    exit 1;
}

unless (print $lock $$) {
    log_error("Failed to print pid to lockfile: $!") if $debug;
    exit 1;
}

unless (flock($lock, LOCK_EX | LOCK_NB)) {
    log_error("Failed to obtain lock: $!") if $debug;
    exit 1;
}

my $conf_file = "/etc/$script_name.yml";
while (my $token = shift @ARGV) {
    if ($token eq '--configure') {
        configure();
        exit;
    }
    elsif ($token eq '--debug') {
        $debug = 1;
    }
    elsif ($token eq '--usecache') {
        $use_cache = 1;
    }
}

my $conf = get_config();
my $tivo = Tivo::Client->new(
    mak       => $conf->{mak},
    tivo_host => $conf->{tivo_host},
    use_cache => $use_cache,
);

my $util = Tivo::Util->new;
if (exists $conf->{region}) {
    my $rage = TVrage->new(region => $conf->{region});
    $util->rage($rage);
}

my $archive_dir = $conf->{archive_dir};
my $search_index = build_search_index($archive_dir);

unless (chdir($archive_dir)) {
     log_error("Failed to chdir to $archive_dir: $!");
     exit 1;
}

for my $subdir (qw(.meta tv movies)) {
    my $dir = "$archive_dir/$subdir";
    unless (-d $dir) {
        unless (mkdir $dir) {
            log_error("Failed to mkdir $dir: $!");
            exit 1;
        }
    }
}

my $videos = eval { $tivo->query_container({ Container => '/NowPlaying', Recurse => 'Yes'}); } or do {
    my $e = $@;
    log_error($e);
    exit 1;
};

for my $video (@$videos) {
    next if $video->in_progress; # still recording
    download($video);
}



sub download {
    my $video = shift || die 'missing video';

    my $title = $video->title;
    my $ep_title = $video->episode_title || '';

    if (! $video->custom_icon_url || $video->custom_icon_url !~ /save-until-i-delete-recording/) {
        log_error("not marked for save $title $ep_title") if $debug;
        return;
    }

    my $detail = $tivo->get_details( $video->video_details_url );
    $video->video_details( $detail );

    my $filename = eval { $util->get_filename($video); } or do {
        my $e = $@;
        log_error("ragetv problem $title $ep_title: $e");
        return;
    };

    my $tivo_filename = "$filename.tivo";
    my $mpg_filename = "$filename.mpg";
    my $pymeta = $util->get_pymeta($video);
    my $pymeta_file = "$archive_dir/.meta/$mpg_filename.txt";    # default

    # Match any configured file extension (m4v, mpg, etc.).
    for my $ext (@{$conf->{extensions}}) {
        my $found = $search_index->{"$filename.$ext"};
        if ($found) {
            my $basename = (split m{/}, $found)[-1];
            $pymeta_file = "$archive_dir/.meta/$basename.txt";
            write_pymeta($pymeta, $pymeta_file);
            log_error("already downloaded $basename") if $debug;
            set_orig_air_date($detail, $found);
            return;
        }
        else {
            log_error("Failed to find $filename.$ext") if $debug;
        }
    }

    write_pymeta($pymeta, $pymeta_file);
    log_error("downloading $mpg_filename");
    my $request = HTTP::Request->new(GET => $video->content_url);
    $tivo->lwp->show_progress(1) if -t;
    $SIG{INT} = $SIG{TERM} = sub { -f $tivo_filename && unlink($tivo_filename); exit; };
    my $response = $tivo->lwp->request($request, $tivo_filename);
    if ($response->is_error) {
        log_error($response->status_line);
        if (-f $tivo_filename) {
            unless (unlink($tivo_filename)) {
                log_error("Failed to unlink $tivo_filename: $!");
            }
        }
        return;
    }

    # This will handle when the network connection to the tivo fails while downloading.
    # Strange this isn't covered by $response->is_error.
    if ($response->header('x-died')) {
        my $error = (split / at \S+ line \d+/, $response->header('x-died'))[0];
        log_error("Tivo connection lost: $tivo_filename $error");
        unless (unlink($tivo_filename)) {
             log_error("Failed to unlink $tivo_filename: $!");
        }
        return;
    }

    my $dest = "$archive_dir/";
    if ($detail->is_episodic) {
        my $season = 0;
        if ($detail->episode_number =~ /^(\d+)\d{2}$/) {
            $season = $1;
        }
        $dest .= join('/', 'tv', $detail->title, "season$season");
    }
    else {
        $dest .= 'movies';
    }

    eval { make_path($dest); 1; } or do {
        my $e = $@;
        log_error("Failed to mkdir $dest: $e");
        exit 1;
    };

    # Keep all the meta data in the top level and create symlinks that refer to it.
    unless (-l "$dest/.meta") {
        unless (symlink("$archive_dir/.meta", "$dest/.meta")) {
            log_error("Failed to create symlink at $dest/.meta: $!");
            exit 1;
        }
    }

    if ($conf->{tivo_decode}) {
        unless (-f '/usr/local/bin/tivodecode') {
            log_error("tivodecode not found!");
            exit 1;
        }

        my @tivodecode = ('/usr/local/bin/tivodecode', '--mak', $tivo->mak,
            '--out', $mpg_filename, $tivo_filename);
        if (system(@tivodecode) == 0) {
            unless (unlink($tivo_filename)) {
                log_error("Failed to unlink $tivo_filename: $!");
                return;
            }
        }
        else {
            log_error("Failed to decode tivo file to mpeg: $?");
            return;
        }

        unless (move($mpg_filename, $dest)) {
            log_error("Failed to move $mpg_filename to $dest: $!");
            exit 1;
        }

        my $file = join('/', $dest, $mpg_filename);
        $file = transcode($file);
        set_orig_air_date($detail, $file);
    }
    else {
        unless (move($tivo_filename, $dest)) {
            log_error("Failed to move $tivo_filename to $dest: $!");
            exit 1;
        }

        my $file = join('/', $dest, $tivo_filename);
        set_orig_air_date($detail, $file);
    }

    if ($conf->{sleep_for}) {
        sleep $conf->{sleep_for}; # Pause between downloads in attempt to prevent tivo network failure.
    }
}

sub transcode {
    my $file = shift || die 'missing file';

    my $mp4 = $file;
    $mp4 =~ s/mpg$/m4v/;

    my @cmd = (
        '/usr/bin/HandBrakeCLI', '-i', $file, '-o', $mp4,
        qw(--audio 1 --aencoder copy:aac --audio-fallback faac
          --audio-copy-mask aac --preset=Universal
        )
    );

    # HandBrakeCLI will fail on occasion; gui seems to always work.
    if (system(@cmd) == 0) {
        unlink($file);
        return $mp4;
    } else {
        unlink($mp4);
        return $file;
    }
}

sub orig_air_date_as_epoch {
    my $orig_air_date = shift || die 'missing orig_air_date';

    if ($orig_air_date =~ /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z$/) {
        my $year = $1;
        my $mon = $2;
        my $day = $3;
        my $hour = $4;
        my $min = $5;
        my $sec = $6;
        my $epoch = timegm($sec, $min, $hour, $day, --$mon, $year);
        return $epoch;
    }

    return;
}

sub set_orig_air_date {
    my $detail = shift || die 'missing detail object';
    my $file = shift || die 'missing file';

    return unless $detail->is_episodic;

    unless (-f $file) {
        confess "Need full path to file, instead of $file";
    }

    my $orig_air_date = orig_air_date_as_epoch($detail->original_air_date);
    unless (utime($orig_air_date, $orig_air_date, $file)) {
        log_error("Failed to update timestamp for $file: $!");
    }
}

sub write_pymeta {
    my $pymeta = shift || die 'missing pymeta';
    my $file = shift || die 'missing basename';

    if (-f $file) {
        log_error("$file exists") if $debug;
        return;
    }

    my $meta;
    unless (open $meta, '>', $file) {
        log_error("Failed to open $file for write: $!");
        return;
    }
    print $meta $pymeta;
    close $meta or log_error("Failed to close meta handle: $!");
}

sub build_search_index {
    my $dir = shift || die 'missing dir';
    my $index = shift || {};

    opendir my $dh, $dir or die "Failed to opendir $dir: $!";
    for my $file (readdir($dh)) {
        my $path = "$dir/$file";
        next unless -r $path;
        if (-d $path && $file ne '.' && $file ne '..') {
            build_search_index($path, $index);
        }
        elsif (-f $path) {
            $index->{$file} = $path;
        }
    }
    closedir $dh or die "Failed to closedir: $!";

    return wantarray ? %$index : $index;
}

sub log_error {
    my $error = shift || die 'missing error!';
    for my $e (split /\n/, $error) {
        print STDERR "$e\n" if -t STDERR;
        syslog('info', $e);
    }
}

sub get_config {
    if (-f $conf_file) {
        my $conf = eval { LoadFile($conf_file); } or do {
            my $e = $@;
            log_error($e);
            exit 1;
        };
        return $conf;
    }
    else {
        return configure();
    }
}

sub configure {
    unless (-t) {
        log_error("configure needs to be run from a terminal!");
        exit 1;
    }

    print "Enter your tivo's mak: ";
    chomp(my $mak = <STDIN>);

    print "Enter the directory to store videos: ";
    chomp(my $archive_dir = <STDIN>);

    print "Do you want to decode .tivo files to .mpeg? ";
    chomp(my $tivo_decode = <STDIN>);
    $tivo_decode = lc($tivo_decode) eq 'y' ? 1 : 0;
    if ($tivo_decode) {
        my $path = `which tivodecode`;
        chomp $path;
        if ($path) {
            $tivo_decode = $path;
        }
        else {
            log_error("Failed to find path to tivodecode. You'll need to edit $conf_file manually to add the path.");
        }
    }

    print "Enter the tivo's IP hostname or IP address: ";
    chomp(my $tivo_host = <STDIN>);

    my $conf = {
        archive_dir => $archive_dir,
        mak         => $mak,
        tivo_decode => $tivo_decode,
        tivo_host   => $tivo_host,
        sleep_for   => 600,
        # http://en.wikipedia.org/wiki/List_of_file_formats#Video
        # Not listing all known extenstions because it slows things down needlessly.
        extensions => [qw(mpg)],
    };
    eval { DumpFile($conf_file, $conf); 1; } or do {
        my $e = $@;
        log_error($e);
        exit 1;
    };
    return $conf;
}


__END__

=head1 PURPOSE

Download tivo recordings marked as 'keep until I delete' and organize them on a media server.
Intended to be a complement to pyTivo.

=head1 SYNOPSIS

I run it via cron.

 jeremys@jeremys-desktop> cat /etc/cron.d/tivo-archiver 
 @reboot root touch /var/run/tivo-archiver.pid && chown jeremys:jeremys /var/run/tivo-archiver.pid

 jeremys@jeremys-desktop> crontab -l | grep tivo-archiver
 */10 * * * * /home/jeremys/bin/tivo-archiver > /dev/null 2>&1

=head1 Author

Jeremy Singletary <jeremys@rickyninja.net>

=head1 Compatible tivo devices

I wrote this to work with my series 2 tivo.  It has not been tested on any of the others.

=head1 Wishlist

=over

=item remove commercials

I've done this a few times by hand using Avidemux, which is works well and is simple enough.
It's tedious however, and I don't want to do it by hand for every recording I archive.  It
results in significant space savings on your drive though, so it'd be a nice bonus.  It looked
like ffmpeg would be able to identify black frames for me, but I wasn't able to get it to work.

=item delete recordings from tivo

It'd be nice to be able to delete a recording from the tivo via HMO protocol after a
successful download.

=back

=head1 Known Problems

=over

=item Tivo network failure during consecutive downloads

I have a series 2 tivo, and it will drop off the network after many consecutive downloads.
I'm assuming this is a network driver problem.  The tivo still shows it's IP address info as
though it were connected, but I no longer see my pyTivo server, and the tivo is not pingable.
The tivo will recover after a restart.

While troubleshooting this I removed my tivo branded wireless usb adapter, and my tivo
unexpectedly restarted; so you probably don't want to do that while recording is in progress.

To mitigate this issue, I inserted a 10 minute sleep after each download.  The problem persists,
but is greatly diminished.

=item Downloads are slow

This is a limitation of the cpu on series 2 tivos.  These units weren't designed for transferring
lots of content.  From what I've read, the max throughput is 4 Mbs wired or wireless.

In normal use this doesn't really bother me.  It's most annoying when I'm coding a new feature
and I want the downloads to go faster so I can determine if my code changes work as expected.

Due to this limitation I record at High quality, and not Best quality.  I tried Best and then
the transfer speed became an annoyance.  High quality recording of 1 hour of content weighs in
at about 1.6 GB, where Best quality weighs in around 2.6 GB.

=item Same show, different region

Being Human has US and UK versions, and I don't see anything in the tivo data to match the region.
To work around this problem, you can configure your region in /etc/tivo-archiver.yml.  The value for 
this attribute is used to match the country attribute in the tvrage api.

If a show already has correct episode number in tivo data (instead of the production code
or incorrect data), this will be used as a last resort as it tends to be less reliable.

=back
